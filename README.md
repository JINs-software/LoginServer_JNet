#### 구 버전 프로젝트

구 버전 라이브러리인 CLanLibrary를 상속하여 구현한 LoginServer: https://github.com/JINs-software/LoginServer/tree/master

성능 및 기능 7일 테스트는 구 버전의 프로젝트로 진행

<p align="center">
  <img src="https://github.com/user-attachments/assets/94c10b75-1f2e-4191-8637-5edf9650285a" width="600">
</p>

---

### \[개요\]
네트워크 라이브러리 제공 클래스(JNetServer, 구 CLanServer)를 상속받아 로그인 서버를 구현하는 것을 목표로 하였다. 로그인 서버의 필요성과 로그인 서버와 계정 DB 나아가 토큰 .....

게임 서버(월드)에 접속하기 전 계정 정보를 통해 '인증(Auth)'를 거치는 로그인 절차를 수행한다. 이 로그인 절차는 '계정 DB'와 '로그인 서버'의 상호 간의 통신으로 수행된다. 
로그인 서버와 게임 서버는 분리된 상태기에 인증 절차에 대한 확인을 로그인 서버가 발행한 '토큰(token)'을 통해 수행토록 한다.

<p align="center">
  <img src="https://velog.velcdn.com/images/jinh2352/post/f2664473-699f-4643-9b04-f28c6c86a3f4/image.png" width="600">
</p>

클라이언트는 로그인 서버를 통해 인증을 받고, 선택한 게임 월드 서버에 접속하게 된다.
게임 월드 서버 입장에선 해당 클라이언트가 로그인 서버를 거쳐 정당한 인증 절차를 거쳐온 유저임을 식별할 수 있어야 한다. 

인증 절차와 클라이언트의 게임 월드 서버 접속까지의 절차에 있어 두 전제 조건을 갖도록 하였다.

(1) 로그인 서버와 게임 월드 서버 간 통신은 없도록 한다.

(2) 로그인 서버와 클라이언트는 stateless 연결

(1) 조건의 이유는 설계에 따라 허용할 수 있는 부분이지만, 통신에서 비롯된 로직이 불가피하게 추가되는 경우도 있을 것이고, 로그인 서버 자체의 스케일 아웃이 까다로워 질 것이기 때문이다.

(2) 조건의 경우 추후 로그인 서버가 세션과 stateful 연결을 유지하는 것은 불필요한 cpu 자원 낭비라 보았고, 추후 HTTP 프로토콜을 사용하는 서버로 이전을 고려한 상황도 있기 때문이다.

로그인 절차에 케이스들을 예상해보자면 다음과 같을 수 있을 것이다.

(case1)

1) 클라이언트 -> 로그인 서버, ID/Password 전달 및 로그인 요청
2) 로그인 서버 -> 계정 DB, ID/Password을 통한 계정 존재 여부 및 유효성 조회
3) 계정 DB -> 로그인 서버, 쿼리 응답
4) 로그인 서버 -> 클라이언트 및 게임 서버에 토큰 발행 및 전달
5) 클라이언트는 게임 서버 선택 후 해당 게임 서버에 로그인 서버로부터 발급받은 토큰과 함께 접속

<p align="center">
  <img src="https://velog.velcdn.com/images/jinh2352/post/5b35ce1b-7722-4257-b6f8-3c1dbd7288e1/image.png" width="600">
</p>

이 방식에서는 로그인 서버가 계정 DB 쿼리를 거쳐 토큰 발급 시 어떤 게임 서버에 발행한 토큰을 전달할 지 모른다는 것이다. 
클라이언트의 월드 서버 선택까지 선택까지 클라이언트 정보를 유지할 순 있겠지만, 이는 사실상 statefull 구조가 되는 것이고, 로그인 서버가 발급한 토큰을 모든 게임 서버에 전달하는 것도 달리 설계하면 피할 수 있는 불필요한 작업이라 생각되었다. 

(case2)

'(case1)'의 방식 '4) 로그인 서버 -> 클라이언트 및 게임 서버에 토큰 발급'을 생략하고, 아래 과정들을 추가적으로 수행할 수 있을 것이다.

4) 클라이언트에게만 발행한 토큰을 전달, 로그인 서버에서 토큰을 메모리 상에 간직
5) 클라이언트 -> 게임 서버, 로그인 서버로부터 발급받은 토큰과 함께 접근
6) 게임 서버 -> 로그인 서버, 토큰 일치 여부 확인 요청(일치한다면 접속 허용)

<p align="center">
  <img src="https://velog.velcdn.com/images/jinh2352/post/dd432f5e-8267-4df4-9af4-f0665f12c7fc/image.png" width="600">
</p>

이 방식은 게임 서버의 로그인 서버로의 요청과 로그인 서버에서 게임 서버로의 응답이 필요하다. 조건(1)에 위배된다.

<br></br>

---

<br></br>

### \[로그인 서버 설계\]

Redis와 같은 메모리 기반의 데이터베이스에 기반을 둔 '토큰 관리 서버'를 도입함으로써 인증 절차에서의 전제 조건을 만족시키는 설계를 세웠다.
 
클라이언트가 로그인 서버에 접속하면 로그인 서버는 계정 DB에 쿼리를 통해 유효한 계정임을 식별한다. 유효한 계정이라면 토큰을 발행하고 클라이언트에 응답으로써 전달한다. 이는 앞서 예시로 든 'case1, 2'와 동일하다. 
그러나 이 토큰을 게임 서버에 직접 전달하거나, 추후 게임 서버의 토큰 유효성 확인 요청을 처리하기 위해 메모리 상에 간직하지도 않는다. Redis, 토큰 관리 서버에 전달한다.

<p align="center">
  <img src="https://velog.velcdn.com/images/jinh2352/post/fdd8f81b-a152-49ed-a06e-dd0d2cd43c43/image.png" width="600">
</p>

로그인에 성공한 클라이언트는 발행된 토큰과 함께 선택한 게임 서버에 접속을 시도한다. 이 때 게임 서버는 클라이언트의 토큰을 Redis 토큰 관리 서버에 조회하여 일치를 확인한다. 만약 일치하다면 게임 서버로의 클라이언트 수용을 허락한다.

#### JNetLibrary 기반의 로그인 서버

<p align="center">
  <img src="https://velog.velcdn.com/images/jinh2352/post/63557fce-250c-4238-a410-eb4239029522/image.png" width="600">
</p>

로그인 서버와 게임 서버는 JNetLibrary의 JNetServer 클래스를 상속받은 클래스이며, IOCP 작업자 스레드에서 호출하는 수신 이벤트 함수인 OnRecv에 로그인 요청 및 월드 서버 접속 요청을 처리하는 로직 코드를 재정의하는 방식으로 구현하였다. 
즉, 채팅 서버와 같이 별도의 채팅 메시지 처리 스레드를 분기하지 않았다. 

남은 결정 사항은 IOCP 작업자 스레드의 수를 얼마나 생성 및 관리할 것인가 였다. 작업자 스레드에서 처리하는 요청은 계정 DB 및 Redis의 접근이 주가 되기에 두 종류의 DB에 대한 커넥션을 중점으로 고려하였다.

일반적으로 게임 월드 서버의 경우 월드 DB와 하나의 DB 커넥션을 유지할 것으로 예상된다. 여러 커넥션이 맺어진다면 실시간으로 저장되는 게임 서버의 메모리 상태의 시간적 흐름이 꼬일 수 있기 때문이다. 달리 말해 게임 서버 메모리 상태의 직렬화 저장을 보장받지 못할 것이다. 
이를 해결하기 위해선 게임 서버의 IOCP 작업자 스레드가 직접적으로 DB에 삽입 요청을 수행하는 것보다 DB와 연결된 단일 커넥션을 베타적으로 점유하는 스레드를 분리하고, 이 스레드가 소비할 수 있는 쿼리 큐를 두어 서버 메모리 상태의 직렬화 저장으 보장할 수 있을 것이다. 
<p align="center">
  <img src="https://velog.velcdn.com/images/jinh2352/post/9da6d3bb-ff82-4ddc-9acd-d0dec16ad01c/image.png" width="600">
</p>

그러나 로그인 서버에 한정한다면, 순서 꼬임에 대한 염두는 하지 않아도 될 것이다. 단일 DB를 대상으로 여러 개의 커넥션이 있더라도 전달되는 쿼리들이 순서 관계가 지켜질 필요가 없다면 그만일 것이다.

로그인 서버가 AccountDB에 요청하는 쿼리는 계정 존재 여부를 묻는 단편적인 쿼리이기에 트랜잭션도 순서도 고려 대상이 아니다. 또한 서로 다른 클라 간의 상호작용도 없다.
단일 DB 서버가 스케일-업 되어 월드 서버와 단일 커넥션을 유지하는 것이 낭비가 되고, 이에 채널을 나누는 마당에 여러 커넥션을 두어도 무방한 구조에서 단일 DB 쿼리 스레드와 단일 연결을 고집할 필요는 없다 판단하였다. 

위 그림과 같이 DB 연결 스레드(DB Connection Thread) 구조를 유지하는 방향으로 간다면 DB Job 큐를 유지하면서 Job Queue에서 Dequeue하여 DB에 쿼리를 보낼 스레드를 멀티-스레드로 설계할 수 있을 것이다.
멀티-DB 연결 스레드가 폴링 방식으로 수행되는 것이 아닌 DB Job Queue의 삽입을 이벤트로 깨어날 수 있는 또 다른 IOCP 구조로 설계하여 DB 연결 스레드를 관리할 수 있을 것이다. 또한 DB Job큐를 락-프리 큐로 구현 또는 일반적인 동기화 객체와 thread-safe하지 못한 큐를 사용할 수도 있을 것이다. 
<p align="center">
  <img src="https://velog.velcdn.com/images/jinh2352/post/6105284f-8641-462a-895c-68bc24f00ea2/image.png" width="600">
</p>

본래 게임 서버에서 IOCP 작업자 스레드의 역할에서 DB 저장 작업은 불가피한 작업은 아니였으나 N 중 1 의 작업이다. 따라서 이를 잡 큐로 분리하여 저장에서 만큼은 단일 DB 커넥션 상황에서 비동기로 수행하겠다는 의미로 구현되었다. 
그러나 로그인 서버 입장에서 하나의 세션과의 연결과 작업은 곧 로그인 절차이며 DB 접근은 로그인 절차의 단계 중 하나에 포함된다. 하나의 세션에만 국한 시켜보면, 해당 절차 중 한 단계를 비동기로 수행한다 하더라도 의미가 없다는 의미이다.
비동기 요청하고, 재개되는 스레드는 다른 로그인 요청을 받을 수 있지 않을까 할 수도 있다.
하지만 생각해보면 비동기 요청 후 다른 로그인 요청을 받고 다시 비동기 요청을 받는 방식으로 하든, 많은 스레드가 직접적으로 DB에 접근하든(비동기 요청 후 다른 로그인 요청을 받을 수 있는 것을 상쇄할 만큼) 하나의 로그인 요청이 토큰으로써 클라이언트에 응답하는 시간과 단위 시간 당 로그인을 처리하는 수에 대한 성능은 후자가 더 나으면 나았지 떨어지지는 않아보인다. 전자는 DB 잡 큐에 대한 동기화 오버헤드가 추가되기 때문이다.

<p align="center">
  <img src="https://velog.velcdn.com/images/jinh2352/post/90a18974-7eba-433e-baa7-6d7a3fae52b7/image.png" width="600">
</p>

최종 설계안은 DB Job 큐와 DB 연결 스레드 없이 오직 IOCP 작업자 스레드가 로그인 절차를 수행하는 것으로 하였다. 
DB Job 큐와 스레드를 통해 DB로의 비동기 요청 작업을 구현할 수 있었지만, 두 종류의 스레드가 분리된다면 전역(작업자 스레드 간 공유하는)에 계정 정보 관련 맵과 토큰 관련 맵 자료구조가 필요했으며 이에 대한 동기화 오버헤드가 불가피하였다. 
차라리 IOCP 작업자 스레드 수를 많이 늘리고, 각 작업자 스레드가 계정 DB 조회, 토큰 생성, Redis에 토큰 삽입, 클라이언트에 토큰 전달까지의 로직을 한번에 처리하도록 하였다(전역의 자료구조는 더 이상 필요하지 않음).

<p align="center">
  <img src="https://velog.velcdn.com/images/jinh2352/post/4c70c7a0-6a32-432f-87ed-19f90268ef70/image.png" width="600">
</p>


(1) 클라이언트 -> 로그인 서버, 로그인 요청(ID/Password 전송)

(2) 로그인 서버 -> 계정 DB, ID/Password와 함께 계정 확인 쿼리

(3) 로그인 서버, 유효한 계정이라면 토큰 발행

(3-1) 로그인 서버 -> redis 토큰 db, 발행 토큰 전달

(3-2) 로그인 서버 -> 클라이언트, 발행 토큰으로 응답

(4) 클라이언트 -> 월드 서버, 토큰과 함께 월드 접속 요청

(5) 월드 서버 -> redis 토큰 db, 클라이언트의 토큰과 redis 내 토큰 비교 및 유효성 확인

(6) 월드 서버 -> 클라이언트, 월드 접속 수용 여부 응답
